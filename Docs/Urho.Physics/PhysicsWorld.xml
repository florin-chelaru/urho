<Type Name="PhysicsWorld" FullName="Urho.Physics.PhysicsWorld">
  <TypeSignature Language="C#" Value="public class PhysicsWorld : Urho.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PhysicsWorld extends Urho.Component" />
  <AssemblyInfo>
    <AssemblyName>Urho</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Urho.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Physics simulation world component. Should be added only to the root scene node.
            </summary>
    <remarks>
      <para>Urho3D implements rigid body physics simulation using the Bullet library.</para>
      <para>The physics simulation has its own fixed update rate, which by default is 60Hz. When the rendering framerate is higher than the physics update rate, physics motion is interpolated so that it always appears smooth. The update rate can be changed with <see cref="M:Urho.Physics.PhysicsWorld.Fps" /> property. The physics update rate also determines the frequency of fixed timestep scene logic updates. Hard limit for physics steps per frame or adaptive timestep can be configured with <see cref="P:Urho.Physics.PhysicsWorld.MaxSubSteps" /> property. These can help to prevent a "spiral of death" due to the CPU being unable to handle the physics load. However, note that using either can lead to time slowing down (when steps are limited) or inconsistent physics behavior (when using adaptive step.)</para>
      <para>The other physics components are:</para>
      <list type="bullet">
        <item>
          <term>
            <see cref="T:Urho.Physics.RigidBody" />: a physics object instance. Its parameters include mass, linear/angular velocities, friction and restitution.</term>
        </item>
        <item>
          <term>
            <see cref="T:Urho.Physics.CollisionShape" />: defines physics collision geometry. The supported shapes are box, sphere, cylinder, capsule, cone, triangle mesh, convex hull and heightfield terrain (requires the <see cref="T:Urho.Terrain" /> component in the same node.)</term>
        </item>
        <item>
          <term>
            <see cref="T:Urho.Physics.Constraint" />: connects two RigidBodies together, or one <see cref="T:Urho.Physics.RigidBody" /> to a static point in the world. Point, hinge, slider and cone twist constraints are supported.</term>
        </item>
      </list>
      <para>
      </para>
      <format type="text/html">
        <h2>Movement and Collision</h2>
      </format>
      <para>
      </para>
      <para>Both a <see cref="T:Urho.Physics.RigidBody" /> and at least one <see cref="T:Urho.Physics.CollisionShape" /> component must exist in a scene node for it to behave physically (a collision shape by itself does nothing.) Several collision shapes may exist in the same node to create compound shapes. An offset position and rotation relative to the node's transform can be specified for each. Triangle mesh and convex hull geometries require specifying a <see cref="T:Urho.Model" /> resource and the LOD level to use.</para>
      <para>
        <see cref="T:Urho.Physics.CollisionShape" /> provides two APIs for defining the collision geometry. Either setting individual properties such as the shape type or size, or specifying both the shape type and all its properties at once using <see cref="M:Urho.Physics.CollisionShape.SetBox" />, <see cref="M:Urho.Physics.CollisionShape.SetCapsule" /> or <see cref="M:Urho.Physics.CollisionShape.SetTriangleMesh" /> for example.</para>
      <para>RigidBodies can be either static or moving. A body is static if its mass is 0, and moving if the mass is greater than 0. Note that the triangle mesh collision shape is not supported for moving objects; it will not collide properly due to limitations in the Bullet library. In this case the convex hull shape can be used instead.</para>
      <para>The collision behaviour of a rigid body is controlled by several variables. </para>
      <para>First, the collision layer and mask define which other objects to collide with: see <see cref="M:Urho.Physics.RigidBody.SetCollisionLayerAndMask" />. By default a rigid body is on layer 1; the layer will be ANDed with the other body's collision mask to see if the collision should be reported. A rigid body can also be set to trigger mode to only report collisions without actually applying collision forces. This can be used to implement trigger areas. Finally, the friction, rolling friction and restitution coefficients (between 0 - 1) control how kinetic energy is transferred in the collisions. Note that rolling friction is by default zero, and if you want for example a sphere rolling on the floor to eventually stop, you need to set a non-zero rolling friction on both the sphere and floor rigid bodies.</para>
      <para>By default rigid bodies can move and rotate about all 3 coordinate axes when forces are applied. To limit the movement, use <see cref="M:Urho.Physics.RigidBody.SetLinearFactor" /> and <see cref="M:Urho.Physics.RigidBody.SetAngularFactor" /> and set the axes you wish to use to 1 and those you do not wish to use to 0. For example moving humanoid characters are often represented by a capsule shape: to ensure they stay upright and only rotate when you explicitly set the rotation in code, set the angular factor to 0, 0, 0.</para>
      <para>To prevent tunneling of a fast moving rigid body through obstacles, continuous collision detection can be used. It approximates the object as a swept sphere, but has a performance cost, so it should be used only when necessary. Set the <see cref="T:Urho.Physics.RigidBody.CcdRadius" /> and <see cref="T:Urho.Physics.RigidBody.CcdMotionThreshold" /> with non-zero values to enable. To prevent false collisions, the body's actual collision shape should completely contain the radius. The motion threshold is the required motion per simulation step for CCD to kick in: for example a box with size 1 should have motion threshold 1 as well.</para>
      <para>All physics calculations are performed in world space. Nodes containing a <see cref="T:Urho.Physics.RigidBody" /> component should preferably be parented to the <see cref="T:Urho.Scene" /> (root node) to ensure independent motion. For ragdolls this is not absolute, as retaining proper bone hierarchy is more important, but be aware that the ragdoll bones may drift far from the animated model's root scene node.</para>
      <para>When several collision shapes are present in the same node, edits to them can cause redundant mass/inertia update computation in the <see cref="T:Urho.Physics.RigidBody" />. To optimize performance in these cases, the edits can be enclosed between calls to <see cref="M:Urho.Physics.RigidBody.DisableMassUpdate" /> and <see cref="M:Urho.Physics.RigidBody.EnableMassUpdate" />.</para>
      <para>
      </para>
      <format type="text/html">
        <h2>Constraint parameters</h2>
      </format>
      <para>Constraint position (and rotation if relevant) need to be defined in relation to both connected bodies, see <see cref="M:Urho.Physics.Constraint.SetPosition" /> and <see cref="M:Urho.Physics.Constraint.SetOtherPosition" />. If the constraint connects a body to the static world, then the "other body position" and "other body rotation" mean the static end's transform in world space. There is also a helper function <see cref="M:Urho.Physics.Constraint.SetWorldPosition" /> to assign the constraint to a world-space position; this sets both relative positions.</para>
      <para>Specifying the constraint's motion axis instead of rotation is provided as an alternative as it can be more intuitive, see <see cref="M:Urho.Physics.Constraint.SetAxis" />. However, by explicitly specifying a rotation you can be sure the constraint is oriented precisely as you want.</para>
      <para>Hinge, slider and cone twist constraints support defining limits for the motion. To be generic, these are encoded slightly unintuitively into Vector2’s. For a hinge constraint, the low and high limit X coordinates define the minimum and maximum angle in degrees. For example -45 to 45. For a slider constraint, the X coordinates define the maximum linear motion in world space units, and the Y coordinates define maximum angular motion in degrees. The cone twist constraint uses only the high limit to define the maximum angles (minimum angle is always -maximum) in the following manner: The X coordinate is the limit of the twist (main) axis, while Y is the limit of the swinging motion about the other axes.</para>
      <para>
      </para>
      <format type="text/html">
        <h2>Physics events</h2>
      </format>
      <para>The physics world sends 8 types of events during its update step:</para>
      <list type="bullet">
        <item>
          <term>
            <see cref="E:Urho.Physics.PhysicsWorld.PhysicsPreStep" />: before the simulation is stepped.</term>
        </item>
        <item>
          <term>
            <see cref="E:Urho.Physics.PhysicsWorld.PhysicsCollisionStart" />: for each new collision during the simulation step. The
            participating scene nodes will also send <see cref="E:Urho.Node.NodeCollisionStart" /> event.</term>
        </item>
        <item>
          <term>
            <see cref="E:Urho.Physics.PhysicsWorld.PhysicsCollision" /> for each ongoing collision during the simulation step. The participating scene nodes will also send <see cref="E:Urho.Node.NodeCollision" /> events.</term>
        </item>
        <item>
          <term>
            <see cref="E:Urho.Physics.PhysicsWorld.PhysicsCollisionEnd" /> for each collision which has ceased. The participating scene nodes will also send <see cref="E:Urho.Node.NodeCollisionEnd" /> event.</term>
        </item>
        <item>
          <term>
            <see cref="E:Urho.Physics.PhysicsWorld.PhysicsPostStep" /> after the simulation has been stepped.</term>
        </item>
      </list>
      <para>Note that if the rendering framerate is high, the physics might not be stepped at all on each frame: in that case those events will not be sent.</para>
      <para>
      </para>
      <format type="text/html">
        <h2>Reading collision events</h2>
      </format>
      <para>A new or ongoing physics collision event will report the collided scene nodes and rigid bodies, whether either of the bodies is a trigger, and the list of contact points.</para>
      <para>These are returned in a CollisionData array, from the “Contacts” property of the EventArguments for the various physics events.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PhysicsWorld ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Preserve</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PhysicsWorld (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Preserve</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer to the raw unmanaged Urho object.</param>
        <summary>Constructs a new instance of Urho.Physics.PhysicsWorld, given a raw pointer to an unmanaged object</summary>
        <remarks>
          <para>This creates a new managed wrapper for the type using the raw pointer to an unmanaged object.</para>
          <para>Objects that are created in this fashion get registered with the UrhoSharp runtime.</para>
          <para>This is intended to be used by the UrhoSharp runtime, and is not intended to be used by users.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PhysicsWorld (Urho.Context scontext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Urho.Context scontext) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Preserve</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="scontext" Type="Urho.Context" />
      </Parameters>
      <Docs>
        <param name="scontext">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PhysicsWorld (Urho.UrhoObjectFlag emptyFlag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype Urho.UrhoObjectFlag emptyFlag) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Preserve</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="emptyFlag" Type="Urho.UrhoObjectFlag" />
      </Parameters>
      <Docs>
        <param name="emptyFlag">Pass UrhoObjectFlag.Empty.</param>
        <summary>Empty constructor, chain to this constructor when you provide your own constructor that sets the handle field.</summary>
        <remarks>
          <para>This constructor should be invoked by your code if you provide your own constructor that sets the handle field.</para>
          <para>This essentially circumvents the default path that creates a new object and sets the handle and does not call RegisterObject on the target, you must do this on your own constructor.</para>
          <para>You would typically chain to this constructor from your own, and then set the handle to the unmanaged object from your code, and then register your object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCollisionShape">
      <MemberSignature Language="C#" Value="public void AddCollisionShape (Urho.Physics.CollisionShape shape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCollisionShape(class Urho.Physics.CollisionShape shape) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="shape" Type="Urho.Physics.CollisionShape" />
      </Parameters>
      <Docs>
        <param name="shape">To be added.</param>
        <summary>
            Add a collision shape to keep track of. Called by CollisionShape.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddConstraint">
      <MemberSignature Language="C#" Value="public void AddConstraint (Urho.Physics.Constraint joint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddConstraint(class Urho.Physics.Constraint joint) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="joint" Type="Urho.Physics.Constraint" />
      </Parameters>
      <Docs>
        <param name="joint">To be added.</param>
        <summary>
            Add a constraint to keep track of. Called by Constraint.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRigidBody">
      <MemberSignature Language="C#" Value="public void AddRigidBody (Urho.Physics.RigidBody body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRigidBody(class Urho.Physics.RigidBody body) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="Urho.Physics.RigidBody" />
      </Parameters>
      <Docs>
        <param name="body">To be added.</param>
        <summary>
            Add a rigid body to keep track of. Called by RigidBody.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyingTransforms">
      <MemberSignature Language="C#" Value="public bool ApplyingTransforms { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ApplyingTransforms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return whether node dirtying should be disregarded.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CleanupGeometryCache">
      <MemberSignature Language="C#" Value="public void CleanupGeometryCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CleanupGeometryCache() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Clean up the geometry cache.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvexCast">
      <MemberSignature Language="C#" Value="public void ConvexCast (ref Urho.Physics.PhysicsRaycastResult result, Urho.Physics.CollisionShape shape, Urho.Vector3 startPos, Urho.Quaternion startRot, Urho.Vector3 endPos, Urho.Quaternion endRot, uint collisionMask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ConvexCast(valuetype Urho.Physics.PhysicsRaycastResult result, class Urho.Physics.CollisionShape shape, valuetype Urho.Vector3 startPos, valuetype Urho.Quaternion startRot, valuetype Urho.Vector3 endPos, valuetype Urho.Quaternion endRot, unsigned int32 collisionMask) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="Urho.Physics.PhysicsRaycastResult&amp;" RefType="ref" />
        <Parameter Name="shape" Type="Urho.Physics.CollisionShape" />
        <Parameter Name="startPos" Type="Urho.Vector3" />
        <Parameter Name="startRot" Type="Urho.Quaternion" />
        <Parameter Name="endPos" Type="Urho.Vector3" />
        <Parameter Name="endRot" Type="Urho.Quaternion" />
        <Parameter Name="collisionMask" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <param name="shape">To be added.</param>
        <param name="startPos">To be added.</param>
        <param name="startRot">To be added.</param>
        <param name="endPos">To be added.</param>
        <param name="endRot">To be added.</param>
        <param name="collisionMask">To be added.</param>
        <summary>
            Perform a physics world swept convex test using a user-supplied collision shape and return the first hit.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawDebugGeometry">
      <MemberSignature Language="C#" Value="public void DrawDebugGeometry (bool depthTest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawDebugGeometry(bool depthTest) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="depthTest" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="depthTest">To be added.</param>
        <summary>
            Add debug geometry to the debug renderer.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawDebugGeometry">
      <MemberSignature Language="C#" Value="public override void DrawDebugGeometry (Urho.DebugRenderer debug, bool depthTest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void DrawDebugGeometry(class Urho.DebugRenderer debug, bool depthTest) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="debug" Type="Urho.DebugRenderer" />
        <Parameter Name="depthTest" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="debug">To be added.</param>
        <param name="depthTest">To be added.</param>
        <summary>
            Visualize the component as debug geometry.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fps">
      <MemberSignature Language="C#" Value="public int Fps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Fps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return simulation steps per second.
            Or
            Set simulation substeps per second.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="getDebugMode">
      <MemberSignature Language="C#" Value="public int getDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 getDebugMode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Return debug draw flags.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gravity">
      <MemberSignature Language="C#" Value="public Urho.Vector3 Gravity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Urho.Vector3 Gravity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Vector3</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return gravity.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalEdge">
      <MemberSignature Language="C#" Value="public bool InternalEdge { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InternalEdge" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return whether Bullet's internal edge utility for trimesh collisions is enabled.
            Or
            Set whether to use Bullet's internal edge utility for trimesh collisions. Disabled by default.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Interpolation">
      <MemberSignature Language="C#" Value="public bool Interpolation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Interpolation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return whether interpolation between simulation steps is enabled.
            Or
            Set whether to interpolate between simulation steps.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNetworkAngularVelocity">
      <MemberSignature Language="C#" Value="public float MaxNetworkAngularVelocity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 MaxNetworkAngularVelocity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return maximum angular velocity for network replication.
            Or
            Set maximum angular velocity for network replication.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxSubSteps">
      <MemberSignature Language="C#" Value="public int MaxSubSteps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxSubSteps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return maximum number of physics substeps per frame.
            Or
            Set maximum number of physics substeps per frame. 0 (default) is unlimited. Positive values cap the amount. Use a negative value to enable an adaptive timestep. This may cause inconsistent physics behavior.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NumIterations">
      <MemberSignature Language="C#" Value="public int NumIterations { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NumIterations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return number of constraint solver iterations.
            Or
            Set number of constraint solver iterations.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicsCollision">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.Physics.PhysicsCollisionEventArgs&gt; PhysicsCollision;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.Physics.PhysicsCollisionEventArgs&gt; PhysicsCollision" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.Physics.PhysicsCollisionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised for each ongoing collision during the simulation step</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToPhysicsCollision" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicsCollisionEnd">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.Physics.PhysicsCollisionEndEventArgs&gt; PhysicsCollisionEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.Physics.PhysicsCollisionEndEventArgs&gt; PhysicsCollisionEnd" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.Physics.PhysicsCollisionEndEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised for each collision which has ceased.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToPhysicsCollisionEnd" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicsCollisionStart">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.Physics.PhysicsCollisionStartEventArgs&gt; PhysicsCollisionStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.Physics.PhysicsCollisionStartEventArgs&gt; PhysicsCollisionStart" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.Physics.PhysicsCollisionStartEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised or each new collision during the simulation step.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToPhysicsCollisionStart" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicsPostStep">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.Physics.PhysicsPostStepEventArgs&gt; PhysicsPostStep;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.Physics.PhysicsPostStepEventArgs&gt; PhysicsPostStep" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.Physics.PhysicsPostStepEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised when the physics world has stepped.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToPhysicsPostStep" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicsPreStep">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.Physics.PhysicsPreStepEventArgs&gt; PhysicsPreStep;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.Physics.PhysicsPreStepEventArgs&gt; PhysicsPreStep" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.Physics.PhysicsPreStepEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised when the physics world is about to be stepped.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToPhysicsPreStep" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaycastSingle">
      <MemberSignature Language="C#" Value="public void RaycastSingle (ref Urho.Physics.PhysicsRaycastResult result, Urho.Ray ray, float maxDistance, uint collisionMask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaycastSingle(valuetype Urho.Physics.PhysicsRaycastResult result, valuetype Urho.Ray ray, float32 maxDistance, unsigned int32 collisionMask) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="Urho.Physics.PhysicsRaycastResult&amp;" RefType="ref" />
        <Parameter Name="ray" Type="Urho.Ray" />
        <Parameter Name="maxDistance" Type="System.Single" />
        <Parameter Name="collisionMask" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="result">Result is returned in this parameter.   If no body is hit by the <see langword="ray" />, the result is set to position zero, normal zero, distance is set to infinity, hitFraction to zero and the body to zero.</param>
        <param name="ray">Ray that will be used to find a body.</param>
        <param name="maxDistance">Maximum distance to raycast.</param>
        <param name="collisionMask">Collision mask to use.</param>
        <summary>
            Perform a physics world raycast and return the closest hit.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaycastSingleSegmented">
      <MemberSignature Language="C#" Value="public void RaycastSingleSegmented (ref Urho.Physics.PhysicsRaycastResult result, Urho.Ray ray, float maxDistance, float segmentDistance, uint collisionMask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaycastSingleSegmented(valuetype Urho.Physics.PhysicsRaycastResult result, valuetype Urho.Ray ray, float32 maxDistance, float32 segmentDistance, unsigned int32 collisionMask) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="Urho.Physics.PhysicsRaycastResult&amp;" RefType="ref" />
        <Parameter Name="ray" Type="Urho.Ray" />
        <Parameter Name="maxDistance" Type="System.Single" />
        <Parameter Name="segmentDistance" Type="System.Single" />
        <Parameter Name="collisionMask" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="result">Result is returned in this parameter.   If no body is hit by the <see langword="ray" />, the result is set to position zero, normal zero, distance is set to infinity, hitFraction to zero and the body to zero.</param>
        <param name="ray">Ray that will be used to find a body.</param>
        <param name="maxDistance">Maximum distance to raycast.</param>
        <param name="segmentDistance">The segment distance to use for each step</param>
        <param name="collisionMask">Collision mask to use.</param>
        <summary>Perform a physics world segmented raycast and return the closest hit. Useful for big scenes with many bodies.</summary>
        <remarks>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterObject">
      <MemberSignature Language="C#" Value="public static void RegisterObject (Urho.Context context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterObject(class Urho.Context context) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Urho.Context" />
      </Parameters>
      <Docs>
        <param name="context">To be added.</param>
        <summary>
            Register object factory.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveCachedGeometry">
      <MemberSignature Language="C#" Value="public void RemoveCachedGeometry (Urho.Model model);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCachedGeometry(class Urho.Model model) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="model" Type="Urho.Model" />
      </Parameters>
      <Docs>
        <param name="model">To be added.</param>
        <summary>
            Invalidate cached collision geometry for a model.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveCollisionShape">
      <MemberSignature Language="C#" Value="public void RemoveCollisionShape (Urho.Physics.CollisionShape shape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCollisionShape(class Urho.Physics.CollisionShape shape) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="shape" Type="Urho.Physics.CollisionShape" />
      </Parameters>
      <Docs>
        <param name="shape">To be added.</param>
        <summary>
            Remove a collision shape. Called by CollisionShape.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveConstraint">
      <MemberSignature Language="C#" Value="public void RemoveConstraint (Urho.Physics.Constraint joint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveConstraint(class Urho.Physics.Constraint joint) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="joint" Type="Urho.Physics.Constraint" />
      </Parameters>
      <Docs>
        <param name="joint">To be added.</param>
        <summary>
            Remove a constraint. Called by Constraint.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveRigidBody">
      <MemberSignature Language="C#" Value="public void RemoveRigidBody (Urho.Physics.RigidBody body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRigidBody(class Urho.Physics.RigidBody body) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="Urho.Physics.RigidBody" />
      </Parameters>
      <Docs>
        <param name="body">To be added.</param>
        <summary>
            Remove a rigid body. Called by RigidBody.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDebugDepthTest">
      <MemberSignature Language="C#" Value="public void SetDebugDepthTest (bool enable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDebugDepthTest(bool enable) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enable">To be added.</param>
        <summary>
            Set debug geometry depth test mode. Called both by PhysicsWorld itself and physics components.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="setDebugMode">
      <MemberSignature Language="C#" Value="public void setDebugMode (int debugMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void setDebugMode(int32 debugMode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="debugMode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="debugMode">To be added.</param>
        <summary>
            Set debug draw flags.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDebugRenderer">
      <MemberSignature Language="C#" Value="public void SetDebugRenderer (Urho.DebugRenderer debug);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDebugRenderer(class Urho.DebugRenderer debug) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="debug" Type="Urho.DebugRenderer" />
      </Parameters>
      <Docs>
        <param name="debug">To be added.</param>
        <summary>
            Set debug renderer to use. Called both by PhysicsWorld itself and physics components.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetGravity">
      <MemberSignature Language="C#" Value="public void SetGravity (Urho.Vector3 gravity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetGravity(valuetype Urho.Vector3 gravity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gravity" Type="Urho.Vector3" />
      </Parameters>
      <Docs>
        <param name="gravity">To be added.</param>
        <summary>
            Set gravity.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Simulating">
      <MemberSignature Language="C#" Value="public bool Simulating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Simulating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return whether is currently inside the Bullet substep loop.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SphereCast">
      <MemberSignature Language="C#" Value="public void SphereCast (ref Urho.Physics.PhysicsRaycastResult result, Urho.Ray ray, float radius, float maxDistance, uint collisionMask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SphereCast(valuetype Urho.Physics.PhysicsRaycastResult result, valuetype Urho.Ray ray, float32 radius, float32 maxDistance, unsigned int32 collisionMask) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="Urho.Physics.PhysicsRaycastResult&amp;" RefType="ref" />
        <Parameter Name="ray" Type="Urho.Ray" />
        <Parameter Name="radius" Type="System.Single" />
        <Parameter Name="maxDistance" Type="System.Single" />
        <Parameter Name="collisionMask" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <param name="ray">To be added.</param>
        <param name="radius">To be added.</param>
        <param name="maxDistance">To be added.</param>
        <param name="collisionMask">To be added.</param>
        <summary>
            Perform a physics world swept sphere test and return the closest hit.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SplitImpulse">
      <MemberSignature Language="C#" Value="public bool SplitImpulse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SplitImpulse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return whether split impulse collision mode is enabled.
            Or
            Set split impulse collision mode. This is more accurate, but slower. Disabled by default.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToPhysicsCollision">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToPhysicsCollision (Action&lt;Urho.Physics.PhysicsCollisionEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToPhysicsCollision(class System.Action`1&lt;valuetype Urho.Physics.PhysicsCollisionEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.Physics.PhysicsCollisionEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the PhysicsCollision event raised by the PhysicsWorld.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Physics.PhysicsWorld.PhysicsCollision" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToPhysicsCollisionEnd">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToPhysicsCollisionEnd (Action&lt;Urho.Physics.PhysicsCollisionEndEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToPhysicsCollisionEnd(class System.Action`1&lt;valuetype Urho.Physics.PhysicsCollisionEndEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.Physics.PhysicsCollisionEndEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the PhysicsCollisionEnd event raised by the PhysicsWorld.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Physics.PhysicsWorld.PhysicsCollisionEnd" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToPhysicsCollisionStart">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToPhysicsCollisionStart (Action&lt;Urho.Physics.PhysicsCollisionStartEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToPhysicsCollisionStart(class System.Action`1&lt;valuetype Urho.Physics.PhysicsCollisionStartEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.Physics.PhysicsCollisionStartEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the PhysicsCollisionStart event raised by the PhysicsWorld.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Physics.PhysicsWorld.PhysicsCollisionStart" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToPhysicsPostStep">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToPhysicsPostStep (Action&lt;Urho.Physics.PhysicsPostStepEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToPhysicsPostStep(class System.Action`1&lt;valuetype Urho.Physics.PhysicsPostStepEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.Physics.PhysicsPostStepEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the PhysicsPostStep event raised by the PhysicsWorld.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Physics.PhysicsWorld.PhysicsPostStep" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToPhysicsPreStep">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToPhysicsPreStep (Action&lt;Urho.Physics.PhysicsPreStepEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToPhysicsPreStep(class System.Action`1&lt;valuetype Urho.Physics.PhysicsPreStepEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.Physics.PhysicsPreStepEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the PhysicsPreStep event raised by the PhysicsWorld.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Physics.PhysicsWorld.PhysicsPreStep" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public override Urho.StringHash Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Urho.StringHash Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.StringHash</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Urho's type system type.</summary>
        <value>StringHash representing the type for this C# type.</value>
        <remarks>This returns the Urho's type and is surfaced for low-level Urho code.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeName">
      <MemberSignature Language="C#" Value="public override string TypeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TypeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Urho's low-level type name.</summary>
        <value>Stringified low-level type name.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeNameStatic">
      <MemberSignature Language="C#" Value="public static string TypeNameStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string TypeNameStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Urho's low-level type name, accessible as a static method.</summary>
        <value>Stringified low-level type name.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeStatic">
      <MemberSignature Language="C#" Value="public static Urho.StringHash TypeStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype Urho.StringHash TypeStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Preserve</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Urho.StringHash</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Urho's low-level type, accessible as a static method.</summary>
        <value>This returns the Urho's type and is surface for the low-level Urho code.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update (float timeStep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update(float32 timeStep) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeStep" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="timeStep">To be added.</param>
        <summary>
            Step the simulation forward.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateCollisions">
      <MemberSignature Language="C#" Value="public void UpdateCollisions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateCollisions() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Refresh collisions only without updating dynamics.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateEnabled">
      <MemberSignature Language="C#" Value="public bool UpdateEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UpdateEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return whether physics world will automatically simulate during scene update.
            Or
            Enable or disable automatic physics simulation during scene update. Enabled by default.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
